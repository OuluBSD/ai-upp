//------------------------------------------------------------------------------
// VERSION 0.9.1
//
// LICENSE
//   This software is dual-licensed to the public domain and under the following
//   license: you are granted a perpetual, irrevocable license to copy, modify,
//   publish, and distribute this file as you see fit.
//
// CREDITS
//   Written by Michal Cichon

// Pseudocode representation of imgui_extra_math.cpp

package thirdparty.imgui-node-editor

// Imports
import imgui_extra_math
import std

//------------------------------------------------------------------------------
# if IMGUI_VERSION_NUM < 19002:
function operator==(lhs: const ImVec2&, rhs: const ImVec2&) -> bool:
    return lhs.x == rhs.x and lhs.y == rhs.y

function operator!=(lhs: const ImVec2&, rhs: const ImVec2&) -> bool:
    return lhs.x != rhs.x or lhs.y != rhs.y
# endif

function operator*(lhs: const float, rhs: const ImVec2&) -> ImVec2:
    return ImVec2(lhs * rhs.x, lhs * rhs.y)

# if IMGUI_VERSION_NUM < 18955:
function operator-(lhs: const ImVec2&) -> ImVec2:
    return ImVec2(-lhs.x, -lhs.y)
# endif

//------------------------------------------------------------------------------
function ImLength(v: float) -> float:
    return v

function ImLength(v: const ImVec2&) -> float:
    return ImSqrt(ImLengthSqr(v))

function ImLengthSqr(v: float) -> float:
    return v * v

function ImNormalized(v: const ImVec2&) -> ImVec2:
    return v * ImInvLength(v, 0.0f)

//------------------------------------------------------------------------------
function ImRect_IsEmpty(rect: const ImRect&) -> bool:
    return rect.Min.x >= rect.Max.x or rect.Min.y >= rect.Max.y

function ImRect_ClosestPoint(rect: const ImRect&, p: const ImVec2&, snap_to_edge: bool) -> ImVec2:
    if not snap_to_edge and rect.Contains(p):
        return p

    return ImVec2(
        if p.x > rect.Max.x: rect.Max.x else if p.x < rect.Min.x: rect.Min.x else p.x,
        if p.y > rect.Max.y: rect.Max.y else if p.y < rect.Min.y: rect.Min.y else p.y
    )

function ImRect_ClosestPoint(rect: const ImRect&, p: const ImVec2&, snap_to_edge: bool, radius: float) -> ImVec2:
    point := ImRect_ClosestPoint(rect, p, snap_to_edge)

    offset      := p - point
    distance_sq := offset.x * offset.x + offset.y * offset.y
    if distance_sq <= 0:
        return point

    distance := ImSqrt(distance_sq)

    return point + offset * (ImMin(distance, radius) * (1.0f / distance))

function ImRect_ClosestPoint(rect: const ImRect&, b: const ImRect&) -> ImVec2:
    result := ImVec2()
    if b.Min.x >= rect.Max.x:
        result.x = rect.Max.x
    elif b.Max.x <= rect.Min.x:
        result.x = rect.Min.x
    else:
        result.x = (ImMax(rect.Min.x, b.Min.x) + ImMin(rect.Max.x, b.Max.x)) / 2

    if b.Min.y >= rect.Max.y:
        result.y = rect.Max.y
    elif b.Max.y <= rect.Min.y:
        result.y = rect.Min.y
    else:
        result.y = (ImMax(rect.Min.y, b.Min.y) + ImMin(rect.Max.y, b.Max.y)) / 2

    return result

function ImRect_ClosestLine(rect_a: const ImRect&, rect_b: const ImRect&) -> ImLine:
    result := ImLine()
    result.A = ImRect_ClosestPoint(rect_a, rect_b)
    result.B = ImRect_ClosestPoint(rect_b, rect_a)

    distribute := lambda a: float&, b: float&, a0: float, a1: float, b0: float, b1: float:
        if a0 >= b1 or a1 <= b0:
            return

        aw := a1 - a0
        bw := b1 - b0

        if aw > bw:
            b = b0 + bw - bw * (a - a0) / aw
            a = b
        elif aw < bw:
            a = a0 + aw - aw * (b - b0) / bw
            b = a

    distribute(result.A.x, result.B.x, rect_a.Min.x, rect_a.Max.x, rect_b.Min.x, rect_b.Max.x)
    distribute(result.A.y, result.B.y, rect_a.Min.y, rect_a.Max.y, rect_b.Min.y, rect_b.Max.y)

    return result

function ImRect_ClosestLine(rect_a: const ImRect&, rect_b: const ImRect&, radius_a: float, radius_b: float) -> ImLine:
    line := ImRect_ClosestLine(rect_a, rect_b)
    if radius_a < 0:
        radius_a = 0
    if radius_b < 0:
        radius_b = 0

    if radius_a == 0 and radius_b == 0:
        return line

    offset      := line.B - line.A
    length_sq   := offset.x * offset.x + offset.y * offset.y
    radius_a_sq := radius_a * radius_a
    radius_b_sq := radius_b * radius_b

    if length_sq <= 0:
        return line

    total_radius_sq := radius_a_sq + radius_b_sq
    if total_radius_sq > length_sq:
        scale := length / (radius_a + radius_b)
        radius_a *= scale
        radius_b *= scale

    line.A = line.A + (offset * (radius_a / length))
    line.B = line.B - (offset * (radius_b / length))

    return line