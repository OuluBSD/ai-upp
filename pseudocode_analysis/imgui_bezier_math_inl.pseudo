//------------------------------------------------------------------------------
// VERSION 0.1
//
// LICENSE
//   This software is dual-licensed to the public domain and under the following
//   license: you are granted a perpetual, irrevocable license to copy, modify,
//   publish, and distribute this file as you see fit.
//
// CREDITS
//   Written by Michal Cichon

// Pseudocode representation of imgui_bezier_math.inl

package thirdparty.imgui-node-editor

// Imports
import imgui_bezier_math
import imgui_extra_math
import map

//------------------------------------------------------------------------------
template <typename T>
function ImLinearBezier(p0: const T&, p1: const T&, t: float) -> T:
    return p0 + t * (p1 - p0)

template <typename T>
function ImLinearBezierDt(p0: const T&, p1: const T&, t: float) -> T:
    IM_UNUSED(t)
    return p1 - p0

template <typename T>
function ImQuadraticBezier(p0: const T&, p1: const T&, p2: const T&, t: float) -> T:
    a := 1 - t
    return a * a * p0 + 2 * t * a * p1 + t * t * p2

template <typename T>
function ImQuadraticBezierDt(p0: const T&, p1: const T&, p2: const T&, t: float) -> T:
    return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1)

template <typename T>
function ImCubicBezier(p0: const T&, p1: const T&, p2: const T&, p3: const T&, t: float) -> T:
    a := 1 - t
    b := a * a * a
    c := t * t * t
    return b * p0 + 3 * t * a * a * p1 + 3 * t * t * a * p2 + c * p3

template <typename T>
function ImCubicBezierDt(p0: const T&, p1: const T&, p2: const T&, p3: const T&, t: float) -> T:
    a := 1 - t
    b := a * a
    c := t * t
    d := 2 * t * a
    return -3 * p0 * b + 3 * p1 * (b - d) + 3 * p2 * (d - c) + 3 * p3 * c

template <typename T>
function ImCubicBezierSample(p0: const T&, p1: const T&, p2: const T&, p3: const T&, t: float) -> T:
    cp0_zero := ImLengthSqr(p1 - p0) < 1e-5f
    cp1_zero := ImLengthSqr(p3 - p2) < 1e-5f

    if cp0_zero and cp1_zero:
        return ImLinearBezier(p0, p3, t)
    elif cp0_zero:
        return ImQuadraticBezier(p0, p2, p3, t)
    elif cp1_zero:
        return ImQuadraticBezier(p0, p1, p3, t)
    else:
        return ImCubicBezier(p0, p1, p2, p3, t)

template <typename T>
function ImCubicBezierSample(curve: const ImCubicBezierPointsT<T>&, t: float) -> T:
    return ImCubicBezierSample(curve.P0, curve.P1, curve.P2, curve.P3, t)

template <typename T>
function ImCubicBezierTangent(p0: const T&, p1: const T&, p2: const T&, p3: const T&, t: float) -> T:
    cp0_zero := ImLengthSqr(p1 - p0) < 1e-5f
    cp1_zero := ImLengthSqr(p3 - p2) < 1e-5f

    if cp0_zero and cp1_zero:
        return ImLinearBezierDt(p0, p3, t)
    elif cp0_zero:
        return ImQuadraticBezierDt(p0, p2, p3, t)
    elif cp1_zero:
        return ImQuadraticBezierDt(p0, p1, p3, t)
    else:
        return ImCubicBezierDt(p0, p1, p2, p3, t)

template <typename T>
function ImCubicBezierTangent(curve: const ImCubicBezierPointsT<T>&, t: float) -> T:
    return ImCubicBezierTangent(curve.P0, curve.P1, curve.P2, curve.P3, t)

template <typename T>
function ImCubicBezierLength(p0: const T&, p1: const T&, p2: const T&, p3: const T&) -> float:
    // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
    t_values := [
        -0.0640568928626056260850430826247450385909f,
         0.0640568928626056260850430826247450385909f,
        -0.1911188674736163091586398207570696318404f,
         0.1911188674736163091586398207570696318404f,
        -0.3150426796961633743867932913198102407864f,
         0.3150426796961633743867932913198102407864f,
        -0.4337935076260451384870842319133497124524f,
         0.4337935076260451384870842319133497124524f,
        -0.5454214713888395356583756172183723700107f,
         0.5454214713888395356583756172183723700107f,
        -0.6480936519369755692524957869107476266696f,
         0.6480936519369755692524957869107476266696f,
        -0.7401241915785543642438281030999784255232f,
         0.7401241915785543642438281030999784255232f,
        -0.8200019859739029219539498726697452080761f,
         0.8200019859739029219539498726697452080761f,
        -0.8864155270044010342131543419821967550873f,
         0.8864155270044010342131543419821967550873f,
        -0.9382745520027327585236490017087214496548f,
         0.9382745520027327585236490017087214496548f,
        -0.9747285559713094981983919930081690617411f,
         0.9747285559713094981983919930081690617411f,
        -0.9951872199970213601799974097007368118745f,
         0.9951872199970213601799974097007368118745f
    ]

    // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
    c_values := [
        0.1279381953467521569740561652246953718517f,
        0.1279381953467521569740561652246953718517f,
        0.1258374563468282961213753825111836887264f,
        0.1258374563468282961213753825111836887264f,
        0.1216704729278033912044631534762624256070f,
        0.1216704729278033912044631534762624256070f,
        0.1155056680537256013533444839067835598622f,
        0.1155056680537256013533444839067835598622f,
        0.1074442701159656347825773424466062227946f,
        0.1074442701159656347825773424466062227946f,
        0.0976186521041138882698806644642471544279f,
        0.0976186521041138882698806644642471544279f,
        0.0861901615319532759171852029837426671850f,
        0.0861901615319532759171852029837426671850f,
        0.0733464814110803057340336152531165181193f,
        0.0733464814110803057340336152531165181193f,
        0.0592985849154367807463677585001085845412f,
        0.0592985849154367807463677585001085845412f,
        0.0442774388174198061686027482113382288593f,
        0.0442774388174198061686027482113382288593f,
        0.0285313886289336631813078159518782864491f,
        0.0285313886289336631813078159518782864491f,
        0.0123412297999871995468056670700372915759f,
        0.0123412297999871995468056670700372915759f
    ]

    static_assert(sizeof(t_values) / sizeof(*t_values) == sizeof(c_values) / sizeof(*c_values), "")

    arc := lambda t: float -> float:
        p := ImCubicBezierDt(p0, p1, p2, p3, t)
        l := ImLength(p)
        return l

    z := 0.5f
    n := sizeof(t_values) / sizeof(*t_values)

    accumulator := 0.0f
    for i := 0; i < n; ++i:
        t := z * t_values[i] + z
        accumulator += c_values[i] * arc(t)

    return z * accumulator

template <typename T>
function ImCubicBezierLength(curve: const ImCubicBezierPointsT<T>&) -> float:
    return ImCubicBezierLength(curve.P0, curve.P1, curve.P2, curve.P3)

template <typename T>
function ImCubicBezierSplit(p0: const T&, p1: const T&, p2: const T&, p3: const T&, t: float) -> ImCubicBezierSplitResultT<T>:
    z1 := t
    z2 := z1 * z1
    z3 := z1 * z1 * z1
    s1 := z1 - 1
    s2 := s1 * s1
    s3 := s1 * s1 * s1

    return ImCubicBezierSplitResultT<T>(
        Left := ImCubicBezierPointsT<T> {
            p0,
            z1      * p1 - s1 * p0,
            z2      * p2 - 2 * z1 * s1 * p1 + s2 * p0,
            z3 * p3 - 3 * z2 * s1 * p2 + 3 * z1 * s2 * p1 - s3 * p0
        },
        Right := ImCubicBezierPointsT<T> {
            z3 * p0 - 3 * z2 * s1 * p1 + 3 * z1 * s2 * p2 - s3 * p3,
            z2      * p1 - 2 * z1 * s1 * p2 + s2 * p3,
            z1      * p2 - s1 * p3,
            p3
        }
    )

template <typename T>
function ImCubicBezierSplit(curve: const ImCubicBezierPointsT<T>&, t: float) -> ImCubicBezierSplitResultT<T>:
    return ImCubicBezierSplit(curve.P0, curve.P1, curve.P2, curve.P3, t)

function ImCubicBezierBoundingRect(p0: const ImVec2&, p1: const ImVec2&, p2: const ImVec2&, p3: const ImVec2&) -> ImRect:
    a := 3 * p3 - 9 * p2 + 9 * p1 - 3 * p0
    b := 6 * p0 - 12 * p1 + 6 * p2
    c := 3 * p1 - 3 * p0
    delta_squared := ImMul(b, b) - 4 * ImMul(a, c)

    tl := ImMin(p0, p3)
    rb := ImMax(p0, p3)

    IM_VEC2_INDEX := lambda v, i: *(&v.x + i)

    for i := 0; i < 2; ++i:
        if IM_VEC2_INDEX(a, i) == 0.0f:
            continue

        if IM_VEC2_INDEX(delta_squared, i) >= 0:
            delta := ImSqrt(IM_VEC2_INDEX(delta_squared, i))

            t0 := (-IM_VEC2_INDEX(b, i) + delta) / (2 * IM_VEC2_INDEX(a, i))
            if t0 > 0 and t0 < 1:
                p := ImCubicBezier(IM_VEC2_INDEX(p0, i), IM_VEC2_INDEX(p1, i), IM_VEC2_INDEX(p2, i), IM_VEC2_INDEX(p3, i), t0)
                IM_VEC2_INDEX(tl, i) := ImMin(IM_VEC2_INDEX(tl, i), p)
                IM_VEC2_INDEX(rb, i) := ImMax(IM_VEC2_INDEX(rb, i), p)
            }

            t1 := (-IM_VEC2_INDEX(b, i) - delta) / (2 * IM_VEC2_INDEX(a, i))
            if t1 > 0 and t1 < 1:
                p := ImCubicBezier(IM_VEC2_INDEX(p0, i), IM_VEC2_INDEX(p1, i), IM_VEC2_INDEX(p2, i), IM_VEC2_INDEX(p3, i), t1)
                IM_VEC2_INDEX(tl, i) := ImMin(IM_VEC2_INDEX(tl, i), p)
                IM_VEC2_INDEX(rb, i) := ImMax(IM_VEC2_INDEX(rb, i), p)
            }

    # undef IM_VEC2_INDEX

    return ImRect(tl, rb)

function ImCubicBezierBoundingRect(curve: const ImCubicBezierPoints&) -> ImRect:
    return ImCubicBezierBoundingRect(curve.P0, curve.P1, curve.P2, curve.P3)

function ImProjectOnCubicBezier(point: const ImVec2&, p0: const ImVec2&, p1: const ImVec2&, p2: const ImVec2&, p3: const ImVec2&, subdivisions: const int = 100) -> ImProjectResult:
    epsilon    := 1e-5f
    fixed_step := 1.0f / static_cast<float>(subdivisions - 1)

    result := ImProjectResult()
    result.Point    = point
    result.Time     = 0.0f
    result.Distance = FLT_MAX

    // Step 1: Coarse check
    for i := 0; i < subdivisions; ++i:
        t := i * fixed_step
        p := ImCubicBezier(p0, p1, p2, p3, t)
        s := point - p
        d := ImDot(s, s)

        if d < result.Distance:
            result.Point    = p
            result.Time     = t
            result.Distance = d

    if result.Time == 0.0f or ImFabs(result.Time - 1.0f) <= epsilon:
        result.Distance = ImSqrt(result.Distance)
        return result

    // Step 2: Fine check
    left  := result.Time - fixed_step
    right := result.Time + fixed_step
    step  := fixed_step * 0.1f

    for t := left; t < right + step; t += step:
        p := ImCubicBezier(p0, p1, p2, p3, t)
        s := point - p
        d := ImDot(s, s)

        if d < result.Distance:
            result.Point    = p
            result.Time     = t
            result.Distance = d

    result.Distance = ImSqrt(result.Distance)

    return result

function ImProjectOnCubicBezier(p: const ImVec2&, curve: const ImCubicBezierPoints&, subdivisions: const int) -> ImProjectResult:
    return ImProjectOnCubicBezier(p, curve.P0, curve.P1, curve.P2, curve.P3, subdivisions)

function ImCubicBezierLineIntersect(p0: const ImVec2&, p1: const ImVec2&, p2: const ImVec2&, p3: const ImVec2&, a0: const ImVec2&, a1: const ImVec2&) -> ImCubicBezierIntersectResult:
    cubic_roots := lambda a, b, c, d, roots: float* -> int:
        count := 0

        sign := lambda x: float -> float: return if x < 0: -1.0f else 1.0f

        A := b / a
        B := c / a
        C := d / a

        Q := (3 * B - ImPow(A, 2)) / 9
        R := (9 * A * B - 27 * C - 2 * ImPow(A, 3)) / 54
        D := ImPow(Q, 3) + ImPow(R, 2)  // polynomial discriminant

        if D >= 0:  // complex or duplicate roots
            S := sign(R + ImSqrt(D)) * ImPow(ImFabs(R + ImSqrt(D)), (1.0f / 3.0f))
            T := sign(R - ImSqrt(D)) * ImPow(ImFabs(R - ImSqrt(D)), (1.0f / 3.0f))

            roots[0] = -A / 3 + (S + T)  // real root
            roots[1] = -A / 3 - (S + T) / 2  // real part of complex root
            roots[2] = -A / 3 - (S + T) / 2  // real part of complex root
            Im := ImFabs(ImSqrt(3) * (S - T) / 2)  // complex part of root pair

            // discard complex roots
            if Im != 0:
                count = 1
            else:
                count = 3
        else:  // distinct real roots
            th := ImAcos(R / ImSqrt(-ImPow(Q, 3)))

            roots[0] = 2 * ImSqrt(-Q) * ImCos(th / 3) - A / 3
            roots[1] = 2 * ImSqrt(-Q) * ImCos((th + 2 * IM_PI) / 3) - A / 3
            roots[2] = 2 * ImSqrt(-Q) * ImCos((th + 4 * IM_PI) / 3) - A / 3

            count = 3

        return count

    // Calculate the coefficients
    c3 := -p0 + 3 * p1 - 3 * p2 + p3
    c2 := 3 * p0 - 6 * p1 + 3 * p2
    c1 := -3 * p0 + 3 * p1
    c0 := p0

    // Convert line to normal form: ax + by + c = 0
    a := a1.y - a0.y
    b := a0.x - a1.x
    c := a0.x * (a0.y - a1.y) + a0.y * (a1.x - a0.x)

    // Rotate each cubic coefficient using line for new coordinate system?
    // Find roots of rotated cubic
    roots := float[3]
    rootCount := cubic_roots(
        a * c3.x + b * c3.y,
        a * c2.x + b * c2.y,
        a * c1.x + b * c1.y,
        a * c0.x + b * c0.y + c,
        roots)

    // Any roots in closed interval [0,1] are intersections on Bezier, but
    // might not be on the line segment.
    // Find intersections and calculate point coordinates

    min := ImMin(a0, a1)
    max := ImMax(a0, a1)

    result := ImCubicBezierIntersectResult()
    points := result.Points

    for i := 0; i < rootCount; ++i:
        root := roots[i]

        if 0 <= root and root <= 1:
            // We're within the Bezier curve
            // Find point on Bezier
            p := ImCubicBezier(p0, p1, p2, p3, root)

            // See if point is on line segment
            // Had to make special cases for vertical and horizontal lines due
            // to slight errors in calculation of p00
            if a0.x == a1.x:
                if min.y <= p.y and p.y <= max.y:
                    *points++ = p
            elif a0.y == a1.y:
                if min.x <= p.x and p.x <= max.x:
                    *points++ = p
            elif p.x >= min.x and p.y >= min.y and p.x <= max.x and p.y <= max.y:
                *points++ = p

    result.Count = static_cast<int>(points - result.Points)

    return result

function ImCubicBezierLineIntersect(curve: const ImCubicBezierPoints&, line: const ImLine&) -> ImCubicBezierIntersectResult:
    return ImCubicBezierLineIntersect(curve.P0, curve.P1, curve.P2, curve.P3, line.A, line.B)

function ImCubicBezierSubdivide(callback: ImCubicBezierSubdivideCallback, user_pointer: void*, p0: const ImVec2&, p1: const ImVec2&, p2: const ImVec2&, p3: const ImVec2&, tess_tol: float, flags: ImCubicBezierSubdivideFlags) -> void:
    return ImCubicBezierSubdivide(callback, user_pointer, ImCubicBezierPoints{ p0, p1, p2, p3 }, tess_tol, flags)

function ImCubicBezierSubdivide(callback: ImCubicBezierSubdivideCallback, user_pointer: void*, curve: const ImCubicBezierPoints&, tess_tol: float, flags: ImCubicBezierSubdivideFlags) -> void:
    struct Tesselator:
        Callback: ImCubicBezierSubdivideCallback
        UserPointer: void*
        TesselationTollerance: float
        Flags: ImCubicBezierSubdivideFlags

        function Commit(p: const ImVec2&, t: const ImVec2&) -> void:
            sample := ImCubicBezierSubdivideSample()
            sample.Point = p
            sample.Tangent = t
            Callback(sample, UserPointer)

        function Subdivide(curve: const ImCubicBezierPoints&, level: int = 0) -> void:
            dx := curve.P3.x - curve.P0.x
            dy := curve.P3.y - curve.P0.y
            d2 := ((curve.P1.x - curve.P3.x) * dy - (curve.P1.y - curve.P3.y) * dx)
            d3 := ((curve.P2.x - curve.P3.x) * dy - (curve.P2.y - curve.P3.y) * dx)
            d2 = if d2 >= 0: d2 else -d2
            d3 = if d3 >= 0: d3 else -d3
            if (d2 + d3) * (d2 + d3) < TesselationTollerance * (dx * dx + dy * dy):
                Commit(curve.P3, ImCubicBezierTangent(curve, 1.0f))
            else if level < 10:
                p12 := (curve.P0 + curve.P1) * 0.5f
                p23 := (curve.P1 + curve.P2) * 0.5f
                p34 := (curve.P2 + curve.P3) * 0.5f
                p123 := (p12 + p23) * 0.5f
                p234 := (p23 + p34) * 0.5f
                p1234 := (p123 + p234) * 0.5f

                Subdivide(ImCubicBezierPoints { curve.P0, p12, p123, p1234 }, level + 1)
                Subdivide(ImCubicBezierPoints { p1234, p234, p34, curve.P3 }, level + 1)

    if tess_tol < 0:
        tess_tol = 1.118f  // sqrtf(1.25f)

    tesselator := Tesselator()
    tesselator.Callback              = callback
    tesselator.UserPointer           = user_pointer
    tesselator.TesselationTollerance = tess_tol * tess_tol
    tesselator.Flags                 = flags

    if not (tesselator.Flags & ImCubicBezierSubdivide_SkipFirst):
        tesselator.Commit(curve.P0, ImCubicBezierTangent(curve, 0.0f))

    tesselator.Subdivide(curve, 0)

template <typename F> function ImCubicBezierSubdivide(callback: F&, p0: const ImVec2&, p1: const ImVec2&, p2: const ImVec2&, p3: const ImVec2&, tess_tol: float, flags: ImCubicBezierSubdivideFlags) -> void:
    handler := lambda p: const ImCubicBezierSubdivideSample&, user_pointer: void*:
        callback := *reinterpret_cast<F*>(user_pointer)
        callback(p)

    ImCubicBezierSubdivide(handler, &callback, ImCubicBezierPoints{ p0, p1, p2, p3 }, tess_tol, flags)

template <typename F> function ImCubicBezierSubdivide(callback: F&, curve: const ImCubicBezierPoints&, tess_tol: float, flags: ImCubicBezierSubdivideFlags) -> void:
    handler := lambda p: const ImCubicBezierSubdivideSample&, user_pointer: void*:
        callback := *reinterpret_cast<F*>(user_pointer)
        callback(p)

    ImCubicBezierSubdivide(handler, &callback, curve, tess_tol, flags)

function ImCubicBezierFixedStep(callback: ImCubicBezierFixedStepCallback, user_pointer: void*, p0: const ImVec2&, p1: const ImVec2&, p2: const ImVec2&, p3: const ImVec2&, step: float, overshoot: bool, max_value_error: float, max_t_error: float) -> void:
    if step <= 0.0f or not callback or max_value_error <= 0 or max_t_error <= 0:
        return

    sample := ImCubicBezierFixedStepSample()
    sample.T           = 0.0f
    sample.Length      = 0.0f
    sample.Point       = p0
    sample.BreakSearch = false

    callback(sample, user_pointer)
    if sample.BreakSearch:
        return

    total_length := ImCubicBezierLength(p0, p1, p2, p3)
    point_count  := static_cast<int>(total_length / step) + (if overshoot: 2 else 1)
    t_min        = 0.0f
    t_max        = step * point_count / total_length
    t_0          = (t_min + t_max) * 0.5f

    # Use map to cache computed lengths
    cache := std.map<float, float>()
    for point_index := 1; point_index < point_count; ++point_index:
        targetLength = point_index * step

        t_start = t_min
        t_end   = t_max
        t       = t_0

        t_best     = t
        error_best = total_length

        while true:
            cacheIt = cache.find(t)
            if cacheIt == cache.end():
                front        = ImCubicBezierSplit(p0, p1, p2, p3, t).Left
                split_length = ImCubicBezierLength(front)

                cacheIt = cache.emplace(t, split_length).first

            length   = cacheIt.second
            error    = targetLength - length

            if error < error_best:
                error_best = error
                t_best     = t

            if ImFabs(error) <= max_value_error or ImFabs(t_start - t_end) <= max_t_error:
                sample.T      = t
                sample.Length = length
                sample.Point  = ImCubicBezier(p0, p1, p2, p3, t)

                callback(sample, user_pointer)
                if sample.BreakSearch:
                    return

                break
            elif error < 0.0f:
                t_end = t
            else:  # if error > 0.0f:
                t_start = t

            t = (t_start + t_end) * 0.5f

function ImCubicBezierFixedStep(callback: ImCubicBezierFixedStepCallback, user_pointer: void*, curve: const ImCubicBezierPoints&, step: float, overshoot: bool, max_value_error: float, max_t_error: float) -> void:
    ImCubicBezierFixedStep(callback, user_pointer, curve.P0, curve.P1, curve.P2, curve.P3, step, overshoot, max_value_error, max_t_error)

# F has signature void(const ImCubicBezierFixedStepSample& p)
template <typename F>
function ImCubicBezierFixedStep(callback: F&, p0: const ImVec2&, p1: const ImVec2&, p2: const ImVec2&, p3: const ImVec2&, step: float, overshoot: bool, max_value_error: float, max_t_error: float) -> void:
    handler := lambda sample: ImCubicBezierFixedStepSample&, user_pointer: void*:
        callback := *reinterpret_cast<F*>(user_pointer)
        callback(sample)

    ImCubicBezierFixedStep(handler, &callback, p0, p1, p2, p3, step, overshoot, max_value_error, max_t_error)

template <typename F>
function ImCubicBezierFixedStep(callback: F&, curve: const ImCubicBezierPoints&, step: float, overshoot: bool, max_value_error: float, max_t_error: float) -> void:
    handler := lambda sample: ImCubicBezierFixedStepSample&, user_pointer: void*:
        callback := *reinterpret_cast<F*>(user_pointer)
        callback(sample)

    ImCubicBezierFixedStep(handler, &callback, curve.P0, curve.P1, curve.P2, curve.P3, step, overshoot, max_value_error, max_t_error)
