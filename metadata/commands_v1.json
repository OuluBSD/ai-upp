{
  "commands": [
    {
      "name": "open_file",
      "category": "file",
      "description": "Open a file in the editor",
      "long_description": "Opens the specified file in the editor window",
      "inputs": [
        {
          "name": "path",
          "type": "path",
          "required": true,
          "description": "Path to the file to open"
        }
      ],
      "outputs": {
        "kind": "status-only"
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "Opens a file in the editor tab"
    },
    {
      "name": "save_file",
      "category": "file",
      "description": "Save the current file or specified file",
      "long_description": "Saves the current file or the specified file to disk",
      "inputs": [
        {
          "name": "path",
          "type": "path",
          "required": false,
          "default": "current",
          "description": "Path to the file to save (current if omitted)"
        }
      ],
      "outputs": {
        "kind": "status-only"
      },
      "side_effects": {
        "modifies_files": true,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "Saves the file to disk, optionally with a new path"
    },
    {
      "name": "find_in_files",
      "category": "search",
      "description": "Search for text pattern in files",
      "long_description": "Searches for a specified pattern in files within a directory",
      "inputs": [
        {
          "name": "pattern",
          "type": "string",
          "required": true,
          "description": "Text pattern to search for"
        },
        {
          "name": "directory",
          "type": "path",
          "required": false,
          "default": ".",
          "description": "Directory to search in (current directory if omitted)"
        },
        {
          "name": "regex",
          "type": "bool",
          "required": false,
          "default": false,
          "description": "Whether to use regex pattern matching"
        }
      ],
      "outputs": {
        "kind": "list",
        "fields": ["file", "line", "match"]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "Searches for text in multiple files recursively"
    },
    {
      "name": "build_project",
      "category": "build",
      "description": "Build the current project",
      "long_description": "Builds the project with the specified configuration",
      "inputs": [
        {
          "name": "name",
          "type": "string",
          "required": true,
          "description": "Name of the project to build"
        },
        {
          "name": "config",
          "type": "enum",
          "enum_values": ["Debug", "Release"],
          "required": false,
          "default": "Debug",
          "description": "Build configuration to use"
        }
      ],
      "outputs": {
        "kind": "status-only"
      },
      "side_effects": {
        "modifies_files": true,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "Calls PackageBuild() to build the project with specified configuration"
    },
    {
      "name": "clean_project",
      "category": "build",
      "description": "Clean the project build artifacts",
      "long_description": "Removes build artifacts from the project",
      "inputs": [
        {
          "name": "name",
          "type": "string",
          "required": true,
          "description": "Name of the project to clean"
        }
      ],
      "outputs": {
        "kind": "status-only"
      },
      "side_effects": {
        "modifies_files": true,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "Cleans the output directory of the project"
    },
    {
      "name": "goto_line",
      "category": "navigation",
      "description": "Go to a specific line in the current file",
      "long_description": "Moves the cursor to the specified line in the file",
      "inputs": [
        {
          "name": "line",
          "type": "int",
          "required": true,
          "description": "Line number to go to"
        },
        {
          "name": "file",
          "type": "path",
          "required": false,
          "description": "File to go to line in (current file if omitted)"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "pos",
            "type": "int",
            "description": "Resolved character offset in the file"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "Navigates to a specific line in the in-memory editor buffer"
    },
    {
      "name": "search_code",
      "category": "search",
      "description": "Search code across the project",
      "long_description": "Searches for symbols, functions, or text across the entire project",
      "inputs": [
        {
          "name": "query",
          "type": "string",
          "required": true,
          "description": "Search query"
        }
      ],
      "outputs": {
        "kind": "list",
        "fields": ["file", "line", "match"]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "Searches symbols and references across the project"
    },
    {
      "name": "show_console",
      "category": "panel",
      "description": "Show the console panel",
      "long_description": "Displays the console panel showing build output and messages",
      "inputs": [],
      "outputs": {
        "kind": "status-only"
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "Shows/hides the console output panel"
    },
    {
      "name": "show_errors",
      "category": "panel",
      "description": "Show the errors panel",
      "long_description": "Displays the errors panel showing compilation errors and warnings",
      "inputs": [],
      "outputs": {
        "kind": "status-only"
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "Shows/hides the errors and warnings panel"
    },
    {
      "name": "set_main_package",
      "category": "project",
      "description": "Set the main package for the project",
      "long_description": "Sets the specified package as the main package for the project",
      "inputs": [
        {
          "name": "package",
          "type": "string",
          "required": true,
          "description": "Name of the package to set as main"
        }
      ],
      "outputs": {
        "kind": "status-only"
      },
      "side_effects": {
        "modifies_files": true,
        "modifies_project": true,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "Changes the main package setting in the project"
    },
    {
      "name": "insert_text",
      "category": "editor",
      "description": "Insert text at a specific position in a file",
      "long_description": "Inserts the specified text at the given position in the file",
      "inputs": [
        {
          "name": "path",
          "type": "path",
          "required": true,
          "description": "Path to the file to edit"
        },
        {
          "name": "pos",
          "type": "int",
          "required": true,
          "description": "Position (0-based) to insert text at"
        },
        {
          "name": "text",
          "type": "string",
          "required": true,
          "description": "Text to insert"
        }
      ],
      "outputs": {
        "kind": "status-only"
      },
      "side_effects": {
        "modifies_files": true,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "Operates on in-memory buffer (CoreEditor). File will be persisted to disk when saved with save_file command."
    },
    {
      "name": "erase_range",
      "category": "editor",
      "description": "Erase a range of text in a file",
      "long_description": "Removes text from the specified position for the given count of characters",
      "inputs": [
        {
          "name": "path",
          "type": "path",
          "required": true,
          "description": "Path to the file to edit"
        },
        {
          "name": "pos",
          "type": "int",
          "required": true,
          "description": "Starting position (0-based) to erase from"
        },
        {
          "name": "count",
          "type": "int",
          "required": true,
          "description": "Number of characters to erase"
        }
      ],
      "outputs": {
        "kind": "status-only"
      },
      "side_effects": {
        "modifies_files": true,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "Operates on in-memory buffer (CoreEditor). File will be persisted to disk when saved with save_file command."
    },
    {
      "name": "replace_all",
      "category": "editor",
      "description": "Replace all occurrences of a pattern in a file",
      "long_description": "Finds and replaces all occurrences of the pattern with the replacement text",
      "inputs": [
        {
          "name": "path",
          "type": "path",
          "required": true,
          "description": "Path to the file to edit"
        },
        {
          "name": "pattern",
          "type": "string",
          "required": true,
          "description": "Pattern to find and replace"
        },
        {
          "name": "replacement",
          "type": "string",
          "required": true,
          "description": "Text to replace the pattern with"
        },
        {
          "name": "case_sensitive",
          "type": "bool",
          "required": false,
          "default": true,
          "description": "Whether the pattern matching is case sensitive"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "replacements",
            "type": "int",
            "description": "Number of replacements made"
          }
        ]
      },
      "side_effects": {
        "modifies_files": true,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "Operates on in-memory buffer (CoreEditor). File will be persisted to disk when saved with save_file command."
    },
    {
      "name": "undo",
      "category": "editor",
      "description": "Undo the last edit in a file",
      "long_description": "Reverts the last edit operation performed on the file",
      "inputs": [
        {
          "name": "path",
          "type": "path",
          "required": true,
          "description": "Path to the file to undo changes in"
        }
      ],
      "outputs": {
        "kind": "status-only"
      },
      "side_effects": {
        "modifies_files": true,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "Operates on in-memory buffer (CoreEditor). File will be persisted to disk when saved with save_file command."
    },
    {
      "name": "redo",
      "category": "editor",
      "description": "Redo the last undone edit in a file",
      "long_description": "Re-applies the last edit that was undone on the file",
      "inputs": [
        {
          "name": "path",
          "type": "path",
          "required": true,
          "description": "Path to the file to redo changes in"
        }
      ],
      "outputs": {
        "kind": "status-only"
      },
      "side_effects": {
        "modifies_files": true,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "Operates on in-memory buffer (CoreEditor). File will be persisted to disk when saved with save_file command."
    },
    {
      "name": "find_definition",
      "category": "navigation",
      "description": "Find the definition of a symbol",
      "long_description": "Locates the definition of the specified symbol in the workspace",
      "inputs": [
        {
          "name": "symbol",
          "type": "string",
          "required": true,
          "description": "Name of the symbol to find the definition for"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "file",
            "type": "path",
            "description": "File containing the definition"
          },
          {
            "name": "line",
            "type": "int",
            "description": "Line number of the definition"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "Requires the workspace to be indexed first using the indexing functionality."
    },
    {
      "name": "find_usages",
      "category": "navigation",
      "description": "Find all usages of a symbol",
      "long_description": "Locates all usages of the specified symbol in the workspace",
      "inputs": [
        {
          "name": "symbol",
          "type": "string",
          "required": true,
          "description": "Name of the symbol to find usages for"
        }
      ],
      "outputs": {
        "kind": "list",
        "fields": [
          {
            "name": "location",
            "type": "string",
            "description": "File and line number in format 'file:line'"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "Requires the workspace to be indexed first using the indexing functionality."
    },
    {
      "name": "get_build_order",
      "category": "graph",
      "description": "Get the build order of packages based on dependencies",
      "long_description": "Returns the topological order of packages based on their dependency relationships, which is the order in which packages should be built",
      "inputs": [],
      "outputs": {
        "kind": "list",
        "fields": ["package"]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command computes the dependency graph and provides the topological sort order for building packages"
    },
    {
      "name": "detect_cycles",
      "category": "graph",
      "description": "Detect cycles in the package dependency graph",
      "long_description": "Identifies cycles in package dependencies that would prevent successful building",
      "inputs": [],
      "outputs": {
        "kind": "list",
        "fields": ["cycle"]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command detects if there are circular dependencies in the package graph"
    },
    {
      "name": "affected_packages",
      "category": "graph",
      "description": "Get packages affected by changes to a file",
      "long_description": "Returns the list of packages that would be affected by changes to the specified file, based on package dependency graph",
      "inputs": [
        {
          "name": "path",
          "type": "path",
          "required": true,
          "description": "Path to the file to check for impact"
        }
      ],
      "outputs": {
        "kind": "list",
        "fields": ["package"]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command performs impact analysis to determine which packages depend (directly or transitively) on the specified file"
    },
    {
      "name": "rename_symbol",
      "category": "refactor",
      "description": "Rename a symbol throughout the workspace",
      "long_description": "Renames a symbol (function, variable, class, etc.) throughout the entire workspace, updating all references",
      "inputs": [
        {
          "name": "old",
          "type": "string",
          "required": true,
          "description": "Current name of the symbol to be renamed"
        },
        {
          "name": "new",
          "type": "string",
          "required": true,
          "description": "New name for the symbol"
        }
      ],
      "outputs": {
        "kind": "list",
        "fields": ["file"]
      },
      "side_effects": {
        "modifies_files": true,
        "modifies_project": true,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command performs workspace-wide symbol renaming using the CoreRefactor engine"
    },
    {
      "name": "remove_dead_includes",
      "category": "refactor",
      "description": "Remove unused include directives from a file",
      "long_description": "Identifies and removes #include directives that are not referenced anywhere in the file",
      "inputs": [
        {
          "name": "path",
          "type": "path",
          "required": true,
          "description": "Path to the file to process"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "removed_includes",
            "type": "int",
            "description": "Number of unused includes removed"
          }
        ]
      },
      "side_effects": {
        "modifies_files": true,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command uses heuristics to determine which includes are unused and can be safely removed"
    },
    {
      "name": "canonicalize_includes",
      "category": "refactor",
      "description": "Canonicalize include paths in a file",
      "long_description": "Standardizes include paths by converting them to the shortest possible relative paths",
      "inputs": [
        {
          "name": "path",
          "type": "path",
          "required": true,
          "description": "Path to the file to process"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "canonicalized_includes",
            "type": "int",
            "description": "Number of includes that were canonicalized"
          }
        ]
      },
      "side_effects": {
        "modifies_files": true,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command resolves relative paths like 'src/../include/foo.h' to canonical forms like 'include/foo.h'"
    },
    {
      "name": "workspace_stats",
      "category": "telemetry",
      "description": "Get statistics about the workspace",
      "long_description": "Provides detailed statistics about the current workspace including packages, files, and their distribution",
      "inputs": [],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "packages",
            "type": "int",
            "description": "Number of packages in the workspace"
          },
          {
            "name": "files",
            "type": "int",
            "description": "Total number of source files"
          },
          {
            "name": "extensions",
            "type": "object",
            "description": "Distribution of files by extension"
          },
          {
            "name": "largest_file",
            "type": "object",
            "description": "Information about the largest file"
          },
          {
            "name": "average_size",
            "type": "int",
            "description": "Average file size in bytes"
          },
          {
            "name": "main_package",
            "type": "string",
            "description": "Name of the main package if set"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command provides insight into the structure and composition of the workspace"
    },
    {
      "name": "package_stats",
      "category": "telemetry",
      "description": "Get statistics about a specific package",
      "long_description": "Provides detailed statistics about a specific package including file count, dependencies, and code metrics",
      "inputs": [
        {
          "name": "package",
          "type": "string",
          "required": true,
          "description": "Name of the package to get statistics for"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "files",
            "type": "int",
            "description": "Number of files in the package"
          },
          {
            "name": "uses_count",
            "type": "int",
            "description": "Number of packages this package uses"
          },
          {
            "name": "include_count",
            "type": "int",
            "description": "Total number of include directives in the package"
          },
          {
            "name": "total_lines",
            "type": "int",
            "description": "Total lines of code in the package"
          },
          {
            "name": "file_size_histogram",
            "type": "object",
            "description": "Histogram of file sizes within the package"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command provides insight into the structure and complexity of a specific package"
    },
    {
      "name": "file_complexity",
      "category": "telemetry",
      "description": "Get complexity metrics for a specific file",
      "long_description": "Provides various complexity metrics for a specific source file",
      "inputs": [
        {
          "name": "path",
          "type": "path",
          "required": true,
          "description": "Path to the file to analyze"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "lines",
            "type": "int",
            "description": "Number of lines in the file"
          },
          {
            "name": "functions",
            "type": "int",
            "description": "Estimated number of functions in the file"
          },
          {
            "name": "includes",
            "type": "int",
            "description": "Number of include directives"
          },
          {
            "name": "nesting",
            "type": "int",
            "description": "Maximum nesting depth of code blocks"
          },
          {
            "name": "comment_ratio",
            "type": "float",
            "description": "Ratio of comment characters to total characters"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "This command provides insight into the complexity metrics of a specific file"
    },
    {
      "name": "graph_stats",
      "category": "telemetry",
      "description": "Get statistics about the dependency graph",
      "long_description": "Provides various metrics about the package dependency graph",
      "inputs": [],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "nodes",
            "type": "int",
            "description": "Number of nodes in the dependency graph"
          },
          {
            "name": "edges",
            "type": "int",
            "description": "Number of edges in the dependency graph"
          },
          {
            "name": "avg_out",
            "type": "float",
            "description": "Average out-degree of nodes"
          },
          {
            "name": "cycles",
            "type": "bool",
            "description": "Whether the graph contains cycles"
          },
          {
            "name": "max_chain",
            "type": "int",
            "description": "Length of the longest dependency chain"
          },
          {
            "name": "most_depended_on",
            "type": "string",
            "description": "Package that is most depended upon"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command provides insight into the structure and health of the dependency graph"
    },
    {
      "name": "edit_history",
      "category": "telemetry",
      "description": "Get history of edits made in the session",
      "long_description": "Provides a list of file edits made during the current session with size deltas",
      "inputs": [],
      "outputs": {
        "kind": "list",
        "fields": [
          {
            "name": "path",
            "type": "path",
            "description": "Path of the file that was edited"
          },
          {
            "name": "delta",
            "type": "int",
            "description": "Change in file size in bytes (negative if file became smaller)"
          },
          {
            "name": "timestamp",
            "type": "datetime",
            "description": "Time when the edit occurred"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "This command provides insight into the change history during the current session"
    },
    {
      "name": "optimize_package",
      "category": "optimize",
      "description": "Run an iterative optimization loop over a package.",
      "long_description": "Runs a series of optimizations repeatedly on a package, measuring improvements between iterations and stopping based on configurable thresholds.",
      "inputs": [
        { "name": "name", "type": "string", "required": true, "description": "Name of the package to optimize" },
        { "name": "max_iterations", "type": "int", "required": false, "default": 5, "description": "Maximum number of optimization iterations to perform" },
        { "name": "converge_threshold", "type": "float", "required": false, "default": 0.01, "description": "Threshold for determining when optimization has converged" },
        { "name": "stop_on_worse", "type": "bool", "default": true, "description": "Stop the optimization loop if metrics worsen" },
        { "name": "stop_on_converge", "type": "bool", "default": true, "description": "Stop the optimization loop when convergence is detected" }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          { "name": "iterations", "type": "array", "description": "Details of each optimization iteration" },
          { "name": "reason", "type": "string", "description": "Reason why the optimization loop terminated" },
          { "name": "success", "type": "bool", "description": "Whether the optimization completed successfully" }
        ]
      },
      "side_effects": {
        "modifies_files": true,
        "modifies_project": true,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command performs iterative structural cleanup of a package, potentially removing dead includes, canonicalizing includes, and other refactoring operations."
    },
    {
      "name": "get_optimization_plan",
      "category": "optimize",
      "description": "Analyze the project and generate an AI-guided improvement plan.",
      "long_description": "Analyzes a package and generates a strategic optimization plan with actionable recommendations.",
      "inputs": [
        { "name": "name", "type": "string", "required": true, "description": "Name of the package to analyze" }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          { "name": "steps", "type": "array", "description": "List of suggested optimization steps" },
          { "name": "summary", "type": "string", "description": "Summary of the optimization plan" },
          { "name": "strategy", "type": "object", "description": "Information about the strategy used to generate the plan" }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command analyzes the package using the AI Supervisor engine to generate a multi-step improvement plan."
    },
    {
      "name": "workspace_plan",
      "category": "optimize",
      "description": "Analyze the entire workspace and generate an AI-guided improvement plan.",
      "long_description": "Analyzes the entire workspace and generates a strategic optimization plan with actionable recommendations.",
      "inputs": [],
      "outputs": {
        "kind": "object",
        "fields": [
          { "name": "steps", "type": "array", "description": "List of suggested optimization steps" },
          { "name": "summary", "type": "string", "description": "Summary of the optimization plan" },
          { "name": "strategy", "type": "object", "description": "Information about the strategy used to generate the plan" }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command analyzes the workspace using the AI Supervisor engine to generate a multi-step improvement plan."
    },
    {
      "name": "list_strategies",
      "category": "strategy",
      "description": "List all available strategies",
      "long_description": "Returns a list of all available strategies with their names and descriptions",
      "inputs": [],
      "outputs": {
        "kind": "list",
        "fields": [
          {
            "name": "name",
            "type": "string",
            "description": "Name of the strategy"
          },
          {
            "name": "description",
            "type": "string",
            "description": "Description of the strategy"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "This command shows all available strategies for the AI Supervisor engine."
    },
    {
      "name": "get_strategy",
      "category": "strategy",
      "description": "Get information about a specific strategy",
      "long_description": "Returns detailed information about a specific strategy or the currently active strategy",
      "inputs": [
        {
          "name": "name",
          "type": "string",
          "required": false,
          "default": "active",
          "description": "Name of the strategy to get information for. If omitted, returns the active strategy."
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "name",
            "type": "string",
            "description": "Name of the strategy"
          },
          {
            "name": "description",
            "type": "string",
            "description": "Description of the strategy"
          },
          {
            "name": "weights",
            "type": "object",
            "description": "Weighting factors used by this strategy"
          },
          {
            "name": "thresholds",
            "type": "object",
            "description": "Threshold values used by this strategy"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "This command provides detailed information about a specific strategy including its weights and thresholds."
    },
    {
      "name": "set_strategy",
      "category": "strategy",
      "description": "Set the current active strategy",
      "long_description": "Sets the active strategy for the AI Supervisor engine",
      "inputs": [
        {
          "name": "name",
          "type": "string",
          "required": true,
          "description": "Name of the strategy to activate"
        }
      ],
      "outputs": {
        "kind": "status-only"
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "This command changes the active strategy used by the AI Supervisor for optimization planning."
    },
    {
      "name": "supervisor_front",
      "category": "strategy",
      "description": "Return the Pareto-optimal suggestions for a package.",
      "inputs": [
        { "name": "package", "type": "string", "required": true }
      ],
      "outputs": { "kind": "array" },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command returns the Pareto-optimal subset of suggestions for the given package, using multi-objective optimization."
    },
    {
      "name": "supervisor_rank",
      "category": "strategy",
      "description": "Rank suggestions by multi-objective weighted score.",
      "inputs": [
        { "name": "package", "type": "string", "required": true },
        { "name": "limit", "type": "int", "required": false, "default": 10 }
      ],
      "outputs": { "kind": "array" },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command ranks suggestions using a weighted linear combination of multi-objective metrics."
    },
    {
      "name": "supervisor_predict",
      "category": "strategy",
      "description": "Predict the value of suggestions for a symbol, file, or entity.",
      "long_description": "Analyzes a symbol, file, or entity and predicts the likely benefit of various suggestions based on project memory and adaptive weights.",
      "inputs": [
        {
          "name": "symbol",
          "type": "string",
          "required": false,
          "description": "Name of the symbol to analyze"
        },
        {
          "name": "file",
          "type": "path",
          "required": false,
          "description": "Path to the file to analyze"
        },
        {
          "name": "entity",
          "type": "string",
          "required": false,
          "description": "Name of a specific entity to analyze"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "predicted_value",
            "type": "float",
            "description": "Predicted value of the suggestions"
          },
          {
            "name": "explanation",
            "type": "object",
            "description": "Explanation fields for the prediction"
          },
          {
            "name": "adaptive_weights",
            "type": "object",
            "description": "Current adaptive weight multipliers"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command uses the Adaptive Priority Engine (APE) to predict which suggestions are likely to yield high-value improvements based on project memory."
    },
    {
      "name": "memory_export",
      "category": "memory",
      "description": "Export the project memory to JSON format.",
      "long_description": "Dumps the complete project memory history to JSON format for backup or transfer to another workspace.",
      "inputs": [
        {
          "name": "path",
          "type": "path",
          "required": false,
          "description": "Path to export the memory file (default: current directory)"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "exported_entries",
            "type": "int",
            "description": "Number of entries exported"
          },
          {
            "name": "output_file",
            "type": "path",
            "description": "Path of the exported file"
          }
        ]
      },
      "side_effects": {
        "modifies_files": true,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "Exports the complete project memory to a JSON file for backup or transfer purposes."
    },
    {
      "name": "memory_import",
      "category": "memory",
      "description": "Import project memory from JSON format.",
      "long_description": "Loads project memory from a JSON file, merging or replacing the current memory.",
      "inputs": [
        {
          "name": "file",
          "type": "path",
          "required": true,
          "description": "Path to the memory file to import"
        },
        {
          "name": "mode",
          "type": "enum",
          "enum_values": ["merge", "replace"],
          "required": false,
          "default": "merge",
          "description": "Import mode: merge adds to current memory, replace overwrites current memory"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "imported_entries",
            "type": "int",
            "description": "Number of entries imported"
          },
          {
            "name": "import_mode",
            "type": "string",
            "description": "The import mode used (merge or replace)"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "Imports project memory from a JSON file, either merging with current memory or replacing it."
    },
    {
      "name": "semantic_entities",
      "category": "semantic",
      "description": "Get all semantic entities in the workspace",
      "long_description": "Returns a list of all semantic entities (classes, functions, etc.) discovered in the workspace with their relationships and attributes",
      "inputs": [],
      "outputs": {
        "kind": "array",
        "fields": [
          {
            "name": "entities",
            "type": "array",
            "description": "Array of semantic entities with name, kind, file, line, relations, and attributes"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command performs semantic analysis to extract all entities in the codebase and their relationships"
    },
    {
      "name": "semantic_clusters",
      "category": "semantic",
      "description": "Get semantic clusters in the workspace",
      "long_description": "Returns a list of semantic clusters, which are groups of tightly related entities in the codebase",
      "inputs": [],
      "outputs": {
        "kind": "array",
        "fields": [
          {
            "name": "clusters",
            "type": "array",
            "description": "Array of semantic clusters with name, entities, and metrics"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command performs semantic clustering to group related entities into conceptual communities"
    },
    {
      "name": "semantic_find",
      "category": "semantic",
      "description": "Find semantic entities by name pattern",
      "long_description": "Searches for semantic entities that match the given pattern",
      "inputs": [
        {
          "name": "pattern",
          "type": "string",
          "required": true,
          "description": "Pattern to search for in entity names"
        }
      ],
      "outputs": {
        "kind": "array",
        "fields": [
          {
            "name": "entities",
            "type": "array",
            "description": "Array of matching semantic entities with name, kind, file, line, relations, and attributes"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command searches for entities by name pattern and returns matching semantic entities"
    },
    {
      "name": "semantic_analyze",
      "category": "semantic",
      "description": "Perform semantic analysis on the workspace",
      "long_description": "Triggers semantic analysis of the entire workspace to extract entities, relationships, and clusters",
      "inputs": [],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "status",
            "type": "string",
            "description": "Analysis status message"
          },
          {
            "name": "entity_count",
            "type": "int",
            "description": "Number of entities discovered"
          },
          {
            "name": "cluster_count",
            "type": "int",
            "description": "Number of clusters identified"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command performs comprehensive semantic analysis of the entire workspace"
    },
    {
      "name": "semantic_subsystems",
      "category": "semantic",
      "description": "Get semantic subsystems in the workspace",
      "long_description": "Returns a list of semantic subsystems, which are groups of entities with inferred conceptual relationships",
      "inputs": [],
      "outputs": {
        "kind": "array",
        "fields": [
          {
            "name": "subsystems",
            "type": "array",
            "description": "Array of semantic subsystems with name, entities, and metrics"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command performs semantic subsystem detection based on inferred relations and clustering"
    },
    {
      "name": "semantic_entity",
      "category": "semantic",
      "description": "Get detailed semantic information for a specific entity",
      "long_description": "Returns full semantic information for one entity including relations and attributes",
      "inputs": [
        {
          "name": "name",
          "type": "string",
          "required": true,
          "description": "Name of the entity to get information for"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "entity",
            "type": "object",
            "description": "Detailed semantic information for the specified entity"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command returns comprehensive semantic information for a specific entity"
    },
    {
      "name": "semantic_roles",
      "category": "semantic",
      "description": "Get semantic roles assigned to entities",
      "long_description": "Returns a mapping of entities to their inferred semantic roles",
      "inputs": [],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "roles",
            "type": "object",
            "description": "Entity to role mapping"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command returns the semantic roles assigned to entities in the workspace"
    },
    {
      "name": "semantic_layers",
      "category": "semantic",
      "description": "Get inferred architectural layers for entities",
      "long_description": "Returns a mapping of entities to their inferred architectural layers",
      "inputs": [],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "layers",
            "type": "object",
            "description": "Entity to architectural layer mapping"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command returns the inferred architectural layers for entities in the workspace"
    },
    {
      "name": "semantic_behavior",
      "category": "semantic",
      "description": "Get behavior signatures for all entities",
      "long_description": "Returns behavior signatures for all entities including pure, io_bound, stateful, transformer, pipeline_stage, etc.",
      "inputs": [],
      "outputs": {
        "kind": "array",
        "fields": [
          {
            "name": "entities",
            "type": "array",
            "description": "Array of entities with their behavior signatures"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command returns comprehensive behavior signatures for all entities in the workspace"
    },
    {
      "name": "semantic_behavior_entity",
      "category": "semantic",
      "description": "Get behavior signature for a specific entity",
      "long_description": "Returns behavior signature for one entity",
      "inputs": [
        {
          "name": "name",
          "type": "string",
          "required": true,
          "description": "Name of the entity to get behavior information for"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "entity",
            "type": "object",
            "description": "Behavior signature for the specified entity"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command returns behavior signature for a specific entity"
    },
    {
      "name": "semantic_behavior_graph",
      "category": "semantic",
      "description": "Get the behavior graph representation",
      "long_description": "Returns the behavior graph with nodes and edges representing behavioral relationships",
      "inputs": [],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "nodes",
            "type": "array",
            "description": "Array of entity names"
          },
          {
            "name": "edges",
            "type": "array",
            "description": "Array of relationships between entities"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command returns the behavior graph with nodes and edges"
    },
    {
      "name": "semantic_pipeline",
      "category": "semantic",
      "description": "Get ordered pipeline stages for the workspace",
      "long_description": "Returns entities organized by their pipeline stage (source, transform, sink)",
      "inputs": [],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "sources",
            "type": "array",
            "description": "Entities classified as sources"
          },
          {
            "name": "transforms",
            "type": "array",
            "description": "Entities classified as transforms"
          },
          {
            "name": "sinks",
            "type": "array",
            "description": "Entities classified as sinks"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command returns entities organized by their pipeline stages"
    },
    {
      "name": "semantic_patterns",
      "category": "semantic",
      "description": "Get detected patterns per entity in the workspace",
      "long_description": "Returns a list of all entities with their recognized architectural patterns",
      "inputs": [],
      "outputs": {
        "kind": "array",
        "fields": [
          {
            "name": "entities",
            "type": "array",
            "description": "Array of entities with their detected patterns"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command returns entities with their recognized architectural patterns such as facade, adapter, factory, etc."
    },
    {
      "name": "semantic_antipatterns",
      "category": "semantic",
      "description": "Get detected anti-patterns per entity in the workspace",
      "long_description": "Returns a list of all entities with their recognized architectural anti-patterns",
      "inputs": [],
      "outputs": {
        "kind": "array",
        "fields": [
          {
            "name": "entities",
            "type": "array",
            "description": "Array of entities with their detected anti-patterns"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command returns entities with their recognized architectural anti-patterns such as god object, cyclic dependencies, etc."
    },
    {
      "name": "semantic_architecture",
      "category": "semantic",
      "description": "Get global architecture diagnostics",
      "long_description": "Returns global architecture diagnostic information including patterns, anti-patterns, and scores",
      "inputs": [],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "patterns",
            "type": "array",
            "description": "Global architecture patterns detected"
          },
          {
            "name": "antipatterns",
            "type": "array",
            "description": "Global architecture anti-patterns detected"
          },
          {
            "name": "scores",
            "type": "object",
            "description": "Architecture quality scores"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command returns global architecture diagnostic information including patterns, anti-patterns, and scores like cohesion, coupling, etc."
    },
    {
      "name": "semantic_outliers",
      "category": "semantic",
      "description": "Get entities that are architectural outliers",
      "long_description": "Returns entities whose metrics fall outside statistical norms for the workspace",
      "inputs": [],
      "outputs": {
        "kind": "array",
        "fields": [
          {
            "name": "outliers",
            "type": "array",
            "description": "Array of outlier entities with their anomalous metrics"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command identifies entities with metrics that significantly deviate from the norm in the workspace"
    },
    {
      "name": "build_scenario",
      "category": "scenario",
      "description": "Build a scenario plan from supervisor suggestions",
      "long_description": "Generates a scenario plan with actions that can be simulated or applied to optimize a package",
      "inputs": [
        {
          "name": "package",
          "type": "string",
          "required": true,
          "description": "Name of the package to build scenario for"
        },
        {
          "name": "max_actions",
          "type": "int",
          "required": false,
          "default": 5,
          "description": "Maximum number of actions to include in the plan"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "name",
            "type": "string",
            "description": "Name of the generated scenario plan"
          },
          {
            "name": "actions",
            "type": "array",
            "description": "Array of actions in the scenario plan"
          },
          {
            "name": "metadata",
            "type": "object",
            "description": "Additional metadata for the scenario plan"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command generates a scenario plan using the AI Supervisor engine recommendations that can be later simulated or applied."
    },
    {
      "name": "simulate_scenario",
      "category": "scenario",
      "description": "Simulate the impact of a scenario without applying changes",
      "long_description": "Estimates the impact of executing a scenario plan without actually making any changes to the codebase",
      "inputs": [
        {
          "name": "plan",
          "type": "json",
          "required": true,
          "description": "JSON string or file path to scenario plan to simulate"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "plan",
            "type": "object",
            "description": "The scenario plan that was simulated"
          },
          {
            "name": "before",
            "type": "object",
            "description": "Metrics and state before the scenario"
          },
          {
            "name": "after",
            "type": "object",
            "description": "Estimated metrics and state after the scenario"
          },
          {
            "name": "deltas",
            "type": "object",
            "description": "Differences between before and after states"
          },
          {
            "name": "applied",
            "type": "bool",
            "description": "Whether changes were actually applied (should be false for simulation)"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command simulates the impact of a scenario plan without making any actual changes to files. It estimates metric changes using heuristics."
    },
    {
      "name": "apply_scenario",
      "category": "scenario",
      "description": "Apply a scenario by executing its actions",
      "long_description": "Actually executes the actions in a scenario plan, making real changes to the codebase",
      "inputs": [
        {
          "name": "plan",
          "type": "json",
          "required": true,
          "description": "JSON string or file path to scenario plan to apply"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "plan",
            "type": "object",
            "description": "The scenario plan that was applied"
          },
          {
            "name": "before",
            "type": "object",
            "description": "Metrics and state before the scenario"
          },
          {
            "name": "after",
            "type": "object",
            "description": "Metrics and state after the scenario"
          },
          {
            "name": "deltas",
            "type": "object",
            "description": "Differences between before and after states"
          },
          {
            "name": "applied",
            "type": "bool",
            "description": "Whether changes were actually applied (should be true for apply)"
          },
          {
            "name": "unified_diff",
            "type": "string",
            "description": "Unified diff representation of the changes made"
          },
          {
            "name": "file_changes",
            "type": "array",
            "description": "Structured summary of file changes"
          }
        ]
      },
      "side_effects": {
        "modifies_files": true,
        "modifies_project": true,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command applies a scenario plan by executing its actions, making real changes to files, refactoring code, or running build operations. Returns patch information about changes made."
    },
    {
      "name": "scenario_diff",
      "category": "scenario",
      "description": "Generate a diff for a scenario without applying it",
      "long_description": "Creates a unified diff representation of what a scenario would change without actually applying the changes",
      "inputs": [
        {
          "name": "plan",
          "type": "json",
          "required": true,
          "description": "JSON string or file path to scenario plan to diff"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "plan",
            "type": "object",
            "description": "The scenario plan that was diffed"
          },
          {
            "name": "before",
            "type": "object",
            "description": "Metrics and state before the scenario"
          },
          {
            "name": "after",
            "type": "object",
            "description": "Estimated metrics and state after the scenario"
          },
          {
            "name": "deltas",
            "type": "object",
            "description": "Differences between before and after states"
          },
          {
            "name": "unified_diff",
            "type": "string",
            "description": "Unified diff representation of the changes"
          },
          {
            "name": "file_changes",
            "type": "array",
            "description": "Structured summary of file changes"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command generates a diff for a scenario plan without applying the changes, useful for previewing what would change."
    },
    {
      "name": "scenario_revert",
      "category": "scenario",
      "description": "Revert changes based on a patch",
      "long_description": "Applies the inverse of a patch to undo changes made by a previous scenario",
      "inputs": [
        {
          "name": "patch",
          "type": "string",
          "required": false,
          "description": "Patch text to revert"
        },
        {
          "name": "patch_file",
          "type": "path",
          "required": false,
          "description": "Path to patch file to revert"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "unified_diff",
            "type": "string",
            "description": "Unified diff representation of the revert changes"
          },
          {
            "name": "file_changes",
            "type": "array",
            "description": "Structured summary of reverted file changes"
          },
          {
            "name": "applied",
            "type": "bool",
            "description": "Whether changes were applied (should be true for revert)"
          }
        ]
      },
      "side_effects": {
        "modifies_files": true,
        "modifies_project": true,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command reverts changes by applying the inverse of a patch generated by this tool, undoing the changes made by a previous scenario."
    },
    {
      "name": "export_proposal",
      "category": "ai",
      "description": "Produces a complete AI-generated change proposal: plan, heuristics, metrics, deltas, semantic/architecture context. No changes are applied.",
      "long_description": "Generates a complete AI change proposal that combines supervisor reasoning, scenario simulation, patch & delta analysis, semantic/architecture insights, risk analysis, and a reproducible execution recipe. No changes are applied in this command.",
      "inputs": [
        {
          "name": "package",
          "type": "string",
          "required": true,
          "description": "Package the proposal concerns"
        },
        {
          "name": "max_actions",
          "type": "int",
          "required": false,
          "default": 5,
          "description": "Maximum number of actions in the proposal"
        },
        {
          "name": "format",
          "type": "enum",
          "enum_values": ["json", "md"],
          "required": false,
          "default": "json",
          "description": "Output format: json for structured data, md for markdown report"
        },
        {
          "name": "with_futures",
          "type": "bool",
          "required": false,
          "default": "false",
          "description": "Whether to include outcome horizon with multi-branch futures analysis"
        }
      ],
      "outputs": {
        "kind": "json",
        "description": "Full proposal as JSON structure containing plan, heuristics, metrics, deltas, semantic/architecture context, and risk/confidence/benefit scores. If with_futures is true, also includes outcome_horizon."
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command produces a machine-reviewable bundle suitable for CI pipelines, code review bots, pull request creation layers, and human review workflows. It combines supervisor reasoning with scenario simulation to provide a comprehensive change proposal. When with_futures is true, it also includes outcome horizon with multi-branch futures analysis for AI-driven decision making."
    },
    {
      "name": "global_stats",
      "category": "cwi",
      "description": "Get statistics from global knowledge base",
      "long_description": "Provides detailed statistics about global knowledge including pattern stats, refactor stats, and topology averages across all workspaces",
      "inputs": [],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "pattern_stats",
            "type": "object",
            "description": "Statistics about historically successful patterns"
          },
          {
            "name": "refactor_stats",
            "type": "object",
            "description": "Statistics about historically successful refactors"
          },
          {
            "name": "topology_stats",
            "type": "object",
            "description": "Statistics about workspace topology metrics"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "This command provides insight into the cross-workspace intelligence gathered from all projects"
    },
    {
      "name": "global_predict",
      "category": "cwi",
      "description": "Predict success likelihood based on global knowledge",
      "long_description": "Analyzes a pattern, refactor or topology and predicts the likely success based on global knowledge and meta-weights",
      "inputs": [
        {
          "name": "pattern",
          "type": "string",
          "required": false,
          "description": "Name of the pattern to analyze"
        },
        {
          "name": "refactor",
          "type": "string",
          "required": false,
          "description": "Name of the refactor to analyze"
        },
        {
          "name": "topology",
          "type": "string",
          "required": false,
          "description": "Name of the topology to analyze"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "prediction",
            "type": "float",
            "description": "Predicted success likelihood"
          },
          {
            "name": "factors",
            "type": "object",
            "description": "Contributing factors to the prediction"
          },
          {
            "name": "meta_weights",
            "type": "object",
            "description": "Current meta-weights used in prediction"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "This command uses Cross-Workspace Intelligence (CWI) to predict which actions are likely to succeed based on global knowledge across all projects."
    },
    {
      "name": "export_global_knowledge",
      "category": "cwi",
      "description": "Export the global knowledge base to JSON format",
      "long_description": "Dumps the complete global knowledge base to JSON format for backup or transfer to another user/workspace",
      "inputs": [
        {
          "name": "path",
          "type": "path",
          "required": false,
          "description": "Path to export the global knowledge file (default: current directory)"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "exported_entries",
            "type": "int",
            "description": "Number of entries exported"
          },
          {
            "name": "output_file",
            "type": "path",
            "description": "Path of the exported file"
          }
        ]
      },
      "side_effects": {
        "modifies_files": true,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "Exports the complete global knowledge base to a JSON file for backup or transfer purposes."
    },
    {
      "name": "import_global_knowledge",
      "category": "cwi",
      "description": "Import global knowledge from JSON format",
      "long_description": "Loads global knowledge from a JSON file, merging with the current global knowledge base",
      "inputs": [
        {
          "name": "file",
          "type": "path",
          "required": true,
          "description": "Path to the global knowledge file to import"
        },
        {
          "name": "mode",
          "type": "enum",
          "enum_values": ["merge", "replace"],
          "required": false,
          "default": "merge",
          "description": "Import mode: merge adds to current global knowledge, replace overwrites current global knowledge"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "imported_entries",
            "type": "int",
            "description": "Number of entries imported"
          },
          {
            "name": "import_mode",
            "type": "string",
            "description": "The import mode used (merge or replace)"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "Imports global knowledge from a JSON file, either merging with current global knowledge or replacing it."
    },
    {
      "name": "lifecycle_phase",
      "category": "lifecycle",
      "description": "Get the current lifecycle phase of the project",
      "long_description": "Analyzes the project's characteristics to determine its current lifecycle phase (early_growth, mature, declining, legacy)",
      "inputs": [],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "name",
            "type": "string",
            "description": "Name of the current lifecycle phase"
          },
          {
            "name": "description",
            "type": "string",
            "description": "Description of the current lifecycle phase"
          },
          {
            "name": "stability",
            "type": "float",
            "description": "Stability metric of the current phase"
          },
          {
            "name": "volatility",
            "type": "float",
            "description": "Volatility metric of the current phase"
          },
          {
            "name": "refactor_bias",
            "type": "float",
            "description": "Refactor bias in the current phase"
          },
          {
            "name": "metrics_used",
            "type": "object",
            "description": "Metrics used to determine the phase"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command analyzes the project using temporal dynamics, architectural metrics, and semantic entropy to determine the current lifecycle phase."
    },
    {
      "name": "lifecycle_phases",
      "category": "lifecycle",
      "description": "List all known lifecycle phases",
      "long_description": "Returns a list of all lifecycle phases recognized by the system with their characteristics",
      "inputs": [],
      "outputs": {
        "kind": "list",
        "fields": [
          {
            "name": "name",
            "type": "string",
            "description": "Name of the lifecycle phase"
          },
          {
            "name": "description",
            "type": "string",
            "description": "Description of the lifecycle phase"
          },
          {
            "name": "stability",
            "type": "float",
            "description": "Stability metric of the phase"
          },
          {
            "name": "volatility",
            "type": "float",
            "description": "Volatility metric of the phase"
          },
          {
            "name": "refactor_bias",
            "type": "float",
            "description": "Refactor bias of the phase"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "This command returns all predefined lifecycle phases with their properties."
    },
    {
      "name": "lifecycle_predict",
      "category": "lifecycle",
      "description": "Predict the effect of lifecycle phase on supervisor decisions and project evolution",
      "long_description": "Analyzes how the current lifecycle phase affects supervisor optimization decisions and projects evolution over future events",
      "inputs": [
        {
          "name": "events",
          "type": "int",
          "required": false,
          "default": 10,
          "description": "Number of events to project future evolution over"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "current_phase",
            "type": "string",
            "description": "Current lifecycle phase"
          },
          {
            "name": "supervisor_impact",
            "type": "object",
            "description": "Impact on supervisor decision making"
          },
          {
            "name": "projected_evolution",
            "type": "list",
            "description": "Projected evolution over specified events"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command analyzes how the current lifecycle phase influences supervisor optimization decisions and forecasts project evolution."
    },
    {
      "name": "lifecycle_predict",
      "category": "lifecycle",
      "description": "Predict the effect of lifecycle phase on supervisor decisions and project evolution",
      "long_description": "Analyzes how the current lifecycle phase affects supervisor optimization decisions and projects evolution over future events",
      "inputs": [
        {
          "name": "events",
          "type": "int",
          "required": false,
          "default": 10,
          "description": "Number of events to project future evolution over"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "current_phase",
            "type": "string",
            "description": "Current lifecycle phase"
          },
          {
            "name": "supervisor_impact",
            "type": "object",
            "description": "Impact on supervisor decision making"
          },
          {
            "name": "projected_evolution",
            "type": "list",
            "description": "Projected evolution over specified events"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command analyzes how the current lifecycle phase influences supervisor optimization decisions and forecasts project evolution."
    },
    {
      "name": "lifecycle_drift",
      "category": "lifecycle",
      "description": "Get the phase drift metrics for the project lifecycle",
      "long_description": "Analyzes the project lifecycle history to calculate drift metrics: phase transitions, oscillations, and stability patterns",
      "inputs": [],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "transitions",
            "type": "int",
            "description": "Total number of phase transitions"
          },
          {
            "name": "back_and_forth",
            "type": "int",
            "description": "Number of oscillations (ABA patterns)"
          },
          {
            "name": "avg_phase_duration",
            "type": "float",
            "description": "Average duration of phases in seconds"
          },
          {
            "name": "stability_index",
            "type": "float",
            "description": "Longitudinal Stability Index (0.0-1.0)"
          },
          {
            "name": "history",
            "type": "array",
            "description": "Timeline of phase changes with timestamps"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command analyzes the lifecycle phase history to detect drift patterns and stability metrics."
    },
    {
      "name": "lifecycle_stability",
      "category": "lifecycle",
      "description": "Get the Longitudinal Stability Index (LSI) for the project",
      "long_description": "Analyzes the project lifecycle history and current metrics to calculate the Longitudinal Stability Index (LSI)",
      "inputs": [],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "stability_index",
            "type": "float",
            "description": "Longitudinal Stability Index (0.0-1.0)"
          },
          {
            "name": "classification",
            "type": "string",
            "description": "Textual classification of stability level"
          },
          {
            "name": "supervisor_impact",
            "type": "string",
            "description": "Description of how stability affects supervisor priorities"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command calculates the Longitudinal Stability Index (LSI) and explains how it affects supervisor decision-making."
    },
    {
      "name": "lifecycle_timeline",
      "category": "lifecycle",
      "description": "Get the complete phase history timeline",
      "long_description": "Returns the complete timeline of lifecycle phase changes with timestamps",
      "inputs": [],
      "outputs": {
        "kind": "array",
        "fields": [
          {
            "name": "timestamp",
            "type": "datetime",
            "description": "Time when the phase was recorded"
          },
          {
            "name": "phase",
            "type": "string",
            "description": "Name of the lifecycle phase"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command returns the complete history of lifecycle phase changes for analysis."
    },
    {
      "name": "orchestrator_add_workspace",
      "category": "orchestrator",
      "description": "Register a workspace for multi-project analysis",
      "long_description": "Adds a workspace path to the MetaOrchestrator for cross-project analysis and roadmap planning",
      "inputs": [
        {
          "name": "path",
          "type": "path",
          "required": true,
          "description": "Path to the workspace root to register"
        }
      ],
      "outputs": {
        "kind": "status-only"
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "This command registers a workspace root path with the MetaOrchestrator for multi-project coordination."
    },
    {
      "name": "orchestrator_summaries",
      "category": "orchestrator",
      "description": "Get summaries for all registered workspaces",
      "long_description": "Returns project summaries with stability, lifecycle phase, and other metrics for all registered workspaces",
      "inputs": [],
      "outputs": {
        "kind": "array",
        "fields": [
          {
            "name": "name",
            "type": "string",
            "description": "Name of the project"
          },
          {
            "name": "path",
            "type": "string",
            "description": "Path to the project"
          },
          {
            "name": "stability",
            "type": "float",
            "description": "Stability metric (0.0-1.0)"
          },
          {
            "name": "lifecycle_phase",
            "type": "string",
            "description": "Current lifecycle phase"
          },
          {
            "name": "entropy",
            "type": "float",
            "description": "Semantic entropy metric"
          },
          {
            "name": "size_loc",
            "type": "int",
            "description": "Lines of code"
          },
          {
            "name": "packages",
            "type": "int",
            "description": "Number of packages in the project"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "This command returns summaries of all registered workspaces with their computed metrics."
    },
    {
      "name": "orchestrator_roadmap",
      "category": "orchestrator",
      "description": "Generate a global roadmap for registered workspaces",
      "long_description": "Builds a coordinated roadmap across multiple workspaces using specified strategy",
      "inputs": [
        {
          "name": "strategy",
          "type": "enum",
          "enum_values": ["default", "stability-first", "risk-distribution", "sequential"],
          "required": false,
          "default": "default",
          "description": "Strategy to use for roadmap generation"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "strategy_name",
            "type": "string",
            "description": "Name of the strategy used"
          },
          {
            "name": "proposals",
            "type": "array",
            "description": "Array of roadmap proposals"
          },
          {
            "name": "global_metrics",
            "type": "object",
            "description": "Global metrics for the roadmap"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "This command generates a cross-workspace roadmap with coordinated optimization suggestions."
    },
    {
      "name": "temporal_seasonality",
      "category": "temporal",
      "description": "Detect seasonality patterns in project lifecycle",
      "long_description": "Analyzes project lifecycle history to detect recurring patterns and seasonal trends in project activity",
      "inputs": [],
      "outputs": {
        "kind": "list",
        "fields": [
          {
            "name": "name",
            "type": "string",
            "description": "Name of the detected seasonality pattern"
          },
          {
            "name": "intensity",
            "type": "float",
            "description": "Intensity of the pattern (0-1)"
          },
          {
            "name": "confidence",
            "type": "float",
            "description": "Confidence in the detection (0-1)"
          },
          {
            "name": "peaks",
            "type": "array",
            "items": {
              "type": "int"
            },
            "description": "Array of iteration points representing peak activity"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command analyzes historical project metrics to detect temporal patterns in development activity."
    },
    {
      "name": "temporal_cadence",
      "category": "temporal",
      "description": "Infer release cadence from project history",
      "long_description": "Analyzes project lifecycle history to infer the average interval between release cycles",
      "inputs": [],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "average_interval",
            "type": "int",
            "description": "Average interval between release cycles in analysis windows"
          },
          {
            "name": "confidence",
            "type": "float",
            "description": "Confidence in the inferred cadence (0-1)"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command analyzes historical project metrics to infer release cycle patterns."
    },
    {
      "name": "temporal_windows",
      "category": "temporal",
      "description": "Predict stability windows for safe changes",
      "long_description": "Predicts time ranges when it's safe to apply refactors or structural changes based on stability analysis",
      "inputs": [],
      "outputs": {
        "kind": "list",
        "fields": [
          {
            "name": "start",
            "type": "int",
            "description": "Start timestamp or iteration index of the stability window"
          },
          {
            "name": "end",
            "type": "int",
            "description": "End timestamp or iteration index of the stability window"
          },
          {
            "name": "predicted_safety",
            "type": "float",
            "description": "Predicted safety score for the window (0-1)"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command predicts optimal time windows for applying structural changes based on temporal analysis."
    },
    {
      "name": "temporal_forecast",
      "category": "temporal",
      "description": "Forecast future lifecycle phases and entropy evolution",
      "long_description": "Uses historical data to predict future lifecycle phases, entropy levels, and confidence scores over a specified horizon",
      "inputs": [
        {
          "name": "horizon",
          "type": "int",
          "required": false,
          "default": 12,
          "description": "Number of timesteps to forecast into the future"
        }
      ],
      "outputs": {
        "kind": "list",
        "fields": [
          {
            "name": "t",
            "type": "int",
            "description": "Future timestep"
          },
          {
            "name": "predicted_phase",
            "type": "string",
            "description": "Predicted lifecycle phase at this timestep"
          },
          {
            "name": "predicted_entropy",
            "type": "float",
            "description": "Predicted entropy level at this timestep"
          },
          {
            "name": "confidence",
            "type": "float",
            "description": "Confidence in the prediction (0-1)"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command uses entropy trend extrapolation to forecast the evolution of the software lifecycle."
    },
    {
      "name": "temporal_risk",
      "category": "temporal",
      "description": "Compute long-term risk profile based on historical patterns",
      "long_description": "Analyzes historical lifecycle data to compute long-term risk metrics including volatility, schedule irregularity, and architectural risk",
      "inputs": [],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "long_term_risk",
            "type": "float",
            "description": "Overall long-term risk score (0-1)"
          },
          {
            "name": "volatility_risk",
            "type": "float",
            "description": "Risk based on entropy volatility (0-1)"
          },
          {
            "name": "schedule_risk",
            "type": "float",
            "description": "Risk based on release schedule irregularity (0-1)"
          },
          {
            "name": "architectural_risk",
            "type": "float",
            "description": "Risk based on architectural entropy trends (0-1)"
          },
          {
            "name": "possible_shocks",
            "type": "list",
            "description": "List of possible shock scenarios with probabilities"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command computes a comprehensive risk profile based on historical lifecycle and release cadence data."
    },
    {
      "name": "temporal_shock",
      "category": "temporal",
      "description": "Simulate disruption shock event impact",
      "long_description": "Simulates the potential impact of specific shock events like developer churn, API breaks, or mass refactors on the project",
      "inputs": [
        {
          "name": "type",
          "type": "enum",
          "enum_values": [
            "developer_churn",
            "api_break",
            "mass_refactor",
            "team_reorg",
            "dependency_break"
          ],
          "required": false,
          "default": "developer_churn",
          "description": "Type of shock event to simulate"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "type",
            "type": "string",
            "description": "Type of shock event simulated"
          },
          {
            "name": "severity",
            "type": "float",
            "description": "Severity of the shock (0-1)"
          },
          {
            "name": "probability",
            "type": "float",
            "description": "Probability of this shock occurring (0-1)"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command simulates the deterministic impact of potential disruption events on the project lifecycle."
    },
    {
      "name": "list_agents",
      "category": "strategic",
      "description": "List all registered strategic agents and their goals",
      "long_description": "Returns a list of all registered strategic agents with their names, preferences, and goals",
      "inputs": [],
      "outputs": {
        "kind": "list",
        "fields": [
          {
            "name": "name",
            "type": "string",
            "description": "Name of the strategic agent"
          },
          {
            "name": "preferences",
            "type": "object",
            "description": "Agent-specific preferences and settings"
          },
          {
            "name": "goals",
            "type": "array",
            "description": "List of goals for this agent"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "This command lists all strategic agents registered in the Strategic Navigator with their configuration."
    },
    {
      "name": "agent_plan",
      "category": "strategic",
      "description": "Generate a strategic plan for a specific agent",
      "long_description": "Builds an optimization plan for the specified agent based on its goals and preferences",
      "inputs": [
        {
          "name": "agent_name",
          "type": "string",
          "required": true,
          "description": "Name of the agent to generate a plan for"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "agent_name",
            "type": "string",
            "description": "Name of the agent that generated the plan"
          },
          {
            "name": "metadata",
            "type": "object",
            "description": "Metadata about the plan generation"
          },
          {
            "name": "proposal",
            "type": "object",
            "description": "Full proposal generated by the agent"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command generates an agent-specific strategic plan based on the agent's goals and weights."
    },
    {
      "name": "global_plan",
      "category": "strategic",
      "description": "Generate a merged global plan from all agents",
      "long_description": "Builds a global optimization plan by merging plans from all registered agents, detecting and resolving conflicts",
      "inputs": [],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "agent_plans",
            "type": "array",
            "description": "List of plans from each individual agent"
          },
          {
            "name": "conflicts",
            "type": "object",
            "description": "Detected conflicts between agent plans"
          },
          {
            "name": "merged",
            "type": "object",
            "description": "Merged global plan with prioritized actions"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command generates a global plan by merging individual agent plans, detecting conflicts and creating a prioritized sequence of actions."
    },
    {
      "name": "resolve_conflicts",
      "category": "strategic",
      "description": "Resolve conflicts between agent plans at the patch level",
      "long_description": "Analyzes conflicts between multiple agent plans and produces a negotiated result with resolved conflicts and trade-off decisions",
      "inputs": [],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "conflicts",
            "type": "array",
            "description": "List of detected conflicts between agent plans"
          },
          {
            "name": "tradeoffs",
            "type": "array",
            "description": "List of evaluated trade-offs and decisions"
          },
          {
            "name": "result",
            "type": "object",
            "description": "Negotiated result with final and discarded actions"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command performs patch-level negotiation between agent plans to resolve conflicts and produce a coherent execution plan."
    },
    {
      "name": "explore_futures",
      "category": "strategic",
      "description": "Explore multiple hypothetical futures based on the current negotiated scenario, returning an outcome horizon for AI agents",
      "long_description": "Explore multiple hypothetical futures based on the current negotiated scenario, returning an outcome horizon for AI agents. The command generates different branches of actions and scores them based on risk, benefit, complexity, and other metrics.",
      "inputs": [],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "branches",
            "type": "array",
            "description": "List of future branches with their projected metrics and scores"
          },
          {
            "name": "best_branch",
            "type": "object",
            "description": "Summary of the top-scoring branch"
          },
          {
            "name": "stats",
            "type": "object",
            "description": "Horizon-level statistics (min/max/avg risk, benefit, etc.)"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command explores multiple alternative futures based on the current negotiated scenario and provides an outcome horizon suitable for AI-driven decision making."
    },
    {
      "name": "evolution_timeline",
      "category": "evolution",
      "description": "Retrieve the timeline of evolution events in the repository",
      "long_description": "Retrieves the full timeline of evolution events that have occurred in the repository, including the types of changes applied, when they were applied, and their outcomes.",
      "inputs": [],
      "outputs": {
        "kind": "array",
        "items": {
          "type": "object",
          "fields": [
            {
              "name": "timestamp",
              "type": "string",
              "description": "When the event occurred"
            },
            {
              "name": "id",
              "type": "string",
              "description": "Unique identifier for the event"
            },
            {
              "name": "package",
              "type": "string",
              "description": "The package the event applied to"
            },
            {
              "name": "agent_name",
              "type": "string",
              "description": "Which agent / strategy profile triggered the change"
            },
            {
              "name": "scenario_id",
              "type": "string",
              "description": "Link to ScenarioPlan / Proposal id"
            },
            {
              "name": "lifecycle_phase",
              "type": "string",
              "description": "Lifecycle phase at time of change"
            },
            {
              "name": "strategy",
              "type": "string",
              "description": "Active strategy profile name"
            },
            {
              "name": "change_kinds",
              "type": "array",
              "items": {
                "type": "string"
              },
              "description": "Categorical characterization of the change ('rename', 'include_cleanup', etc.)"
            },
            {
              "name": "succeeded",
              "type": "boolean",
              "description": "True if applied & kept"
            },
            {
              "name": "reverted",
              "type": "boolean",
              "description": "True if later undone"
            },
            {
              "name": "metrics_before",
              "type": "object",
              "description": "Selected metrics snapshot before the change"
            },
            {
              "name": "metrics_after",
              "type": "object",
              "description": "Selected metrics snapshot after the change"
            },
            {
              "name": "deltas",
              "type": "object",
              "description": "Normalized deltas (complexity, cycles, coupling, etc.)"
            },
            {
              "name": "context",
              "type": "object",
              "description": "Snapshot of drift, stability, seasonality at the time"
            }
          ]
        }
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command provides introspection into the evolution of the codebase, allowing AI agents to understand what types of changes have been applied and with what success rates."
    },
    {
      "name": "evolution_summary",
      "category": "evolution",
      "description": "Retrieve aggregated summary of evolution events and their outcomes",
      "long_description": "Provides an aggregated summary of evolution events, including success rates by change type and strategy, allowing AI agents to understand which approaches have been most effective in this codebase.",
      "inputs": [],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "total_events",
            "type": "integer",
            "description": "Total number of evolution events"
          },
          {
            "name": "successful",
            "type": "integer",
            "description": "Number of successful events"
          },
          {
            "name": "reverted_count",
            "type": "integer",
            "description": "Number of events that were later reverted"
          },
          {
            "name": "by_change_kind",
            "type": "object",
            "description": "Aggregated stats by change kind (e.g., 'rename', 'include_cleanup', etc.)"
          },
          {
            "name": "by_strategy",
            "type": "object",
            "description": "Success/failure and avg benefit/risk by strategy profile"
          },
          {
            "name": "by_phase",
            "type": "object",
            "description": "Preferred change kinds by lifecycle phase"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command provides strategic insights into the evolution of the codebase, allowing AI agents to understand which strategies and types of changes have been most effective historically."
    },
    {
      "name": "list_playbooks",
      "category": "playbook",
      "description": "List available playbooks for automation",
      "long_description": "Returns a list of all playbooks available for execution, including their descriptions, safety levels, and constraints",
      "inputs": [],
      "outputs": {
        "kind": "list",
        "fields": [
          {
            "name": "id",
            "type": "string",
            "description": "Unique identifier of the playbook"
          },
          {
            "name": "description",
            "type": "string",
            "description": "Human-readable description of what the playbook does"
          },
          {
            "name": "safety_level",
            "type": "float",
            "description": "Safety level of the playbook (0.0 to 1.0, higher is more conservative)"
          },
          {
            "name": "constraints",
            "type": "object",
            "description": "Safety constraints applied to the playbook execution"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "This command allows AI agents to discover available high-level automation workflows and their safety characteristics"
    },
    {
      "name": "playbook_self_test",
      "category": "playbook",
      "description": "Runs the playbook test harness for the current workspace (if configured).",
      "long_description": "Executes the playbook test harness to validate that playbooks behave safely and deterministically in the current workspace.",
      "inputs": [],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "status",
            "type": "string",
            "description": "Execution status (success, failed)"
          },
          {
            "name": "test_results",
            "type": "list",
            "description": "List of individual test results with pass/fail status"
          },
          {
            "name": "summary",
            "type": "string",
            "description": "Summary of the test execution"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "This command runs the playbook test harness to validate that playbooks behave safely and deterministically. For v1, it simply prints a message directing users to run the test script directly."
    },
    {
      "name": "run_playbook",
      "category": "playbook",
      "description": "Run a specific playbook",
      "long_description": "Executes a named playbook which may perform multiple coordinated actions according to its predefined workflow",
      "inputs": [
        {
          "name": "playbook_id",
          "type": "string",
          "required": true,
          "description": "ID of the playbook to execute"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "status",
            "type": "string",
            "description": "Execution status (success, failed, blocked_by_constraint)"
          },
          {
            "name": "steps",
            "type": "list",
            "description": "List of steps executed with their results"
          },
          {
            "name": "playbook_id",
            "type": "string",
            "description": "ID of the playbook that was executed"
          },
          {
            "name": "safety_level",
            "type": "float",
            "description": "Safety level of the executed playbook"
          }
        ]
      },
      "side_effects": {
        "modifies_files": true,
        "modifies_project": true,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command executes a named playbook which performs multi-step automation workflows with built-in safety constraints. The steps and results are returned for AI agent inspection."
    },
    {
      "name": "list_regression_specs",
      "category": "regression",
      "description": "List available regression test specifications",
      "long_description": "Returns a list of all available regression test specifications that can be executed",
      "inputs": [],
      "outputs": {
        "kind": "list",
        "fields": [
          {
            "name": "name",
            "type": "string",
            "description": "Name of the regression spec"
          },
          {
            "name": "agent",
            "type": "string",
            "description": "Agent name associated with the spec"
          },
          {
            "name": "scenario",
            "type": "string",
            "description": "Scenario or playbook to execute"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "This command lists all available regression test specifications for agent-based testing"
    },
    {
      "name": "run_regression",
      "category": "regression",
      "description": "Run a specific regression test",
      "long_description": "Executes a regression test using the specified specification name",
      "inputs": [
        {
          "name": "name",
          "type": "string",
          "required": true,
          "description": "Name of the regression spec to run"
        },
        {
          "name": "json",
          "type": "bool",
          "required": false,
          "default": false,
          "description": "Return output in JSON format"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "spec",
            "type": "string",
            "description": "Name of the executed regression spec"
          },
          {
            "name": "agent",
            "type": "string",
            "description": "Agent that executed the test"
          },
          {
            "name": "success",
            "type": "bool",
            "description": "Whether the test execution was successful"
          },
          {
            "name": "metrics",
            "type": "object",
            "description": "Metrics collected during the test"
          },
          {
            "name": "violations",
            "type": "list",
            "description": "List of violations detected during execution"
          },
          {
            "name": "conflicts",
            "type": "list",
            "description": "List of conflicts detected during execution"
          }
        ]
      },
      "side_effects": {
        "modifies_files": true,
        "modifies_project": true,
        "requires_open_project": true,
        "requires_open_file": false
      },
      "context_notes": "This command runs a specific regression test and returns the results including metrics, violations, and conflicts. This command uses a temporary workspace for testing."
    },
    {
      "name": "compare_regressions",
      "category": "regression",
      "description": "Compare results of two regression tests",
      "long_description": "Compares the results of two different regression test executions",
      "inputs": [
        {
          "name": "first_report",
          "type": "path",
          "required": true,
          "description": "Path to the first regression report JSON file"
        },
        {
          "name": "second_report",
          "type": "path",
          "required": true,
          "description": "Path to the second regression report JSON file"
        }
      ],
      "outputs": {
        "kind": "object",
        "fields": [
          {
            "name": "differences",
            "type": "object",
            "description": "Differences between the two reports"
          },
          {
            "name": "metrics_comparison",
            "type": "object",
            "description": "Comparison of metrics between the reports"
          },
          {
            "name": "risk_delta",
            "type": "float",
            "description": "Change in risk assessment between the two tests"
          }
        ]
      },
      "side_effects": {
        "modifies_files": false,
        "modifies_project": false,
        "requires_open_project": false,
        "requires_open_file": false
      },
      "context_notes": "This command compares two regression test reports to identify differences in metrics and outcomes."
    }
  ]
}